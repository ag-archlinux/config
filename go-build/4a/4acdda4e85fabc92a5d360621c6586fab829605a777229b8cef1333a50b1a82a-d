// Code generated by cmd/cgo; DO NOT EDIT.

//line /tmp/yay/src/yay-8.1173.0/.go/src/github.com/jguer/go-alpm/db.go:1:1
// db.go - Functions for database handling.
//
// Copyright (c) 2013 The go-alpm Authors
//
// MIT Licensed. See LICENSE for details.

package alpm; import _cgo_unsafe "unsafe"

/*
#include <alpm.h>
#include <alpm_list.h>
*/
import _ "unsafe"

import (
	"fmt"
	"io"
	"unsafe"
)

// Db structure representing a alpm database.
type Db struct {
	ptr    *_Ctype_struct___alpm_db_t
	handle Handle
}

// DbList structure representing a alpm database list.
type DbList struct {
	*list
	handle Handle
}

// ForEach executes an action on each Db.
func (l DbList) ForEach(f func(Db) error) error {
	return l.forEach(func(p unsafe.Pointer) error {
		return f(Db{(*_Ctype_struct___alpm_db_t)(p), l.handle})
	})
}

// Slice converst Db list to Db slice.
func (l DbList) Slice() []Db {
	slice := []Db{}
	l.ForEach(func(db Db) error {
		slice = append(slice, db)
		return nil
	})
	return slice
}

// LocalDb returns the local database relative to the given handle.
func (h Handle) LocalDb() (*Db, error) {
	db := func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_db_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_get_localdb)(_cgo0);}(h.ptr)
	if db == nil {
		return nil, h.LastError()
	}
	return &Db{db, h}, nil
}

// SyncDbs returns list of Synced DBs.
func (h Handle) SyncDbs() (DbList, error) {
	dblist := func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_get_syncdbs)(_cgo0);}(h.ptr)
	if dblist == nil {
		return DbList{nil, h}, h.LastError()
	}
	dblistPtr := unsafe.Pointer(dblist)
	return DbList{(*list)(dblistPtr), h}, nil
}

// SyncDbByName finds a registered database by name.
func (h Handle) SyncDbByName(name string) (db *Db, err error) {
	dblist, err := h.SyncDbs()
	if err != nil {
		return nil, err
	}
	dblist.ForEach(func(b Db) error {
		if b.Name() == name {
			db = &b
			return io.EOF
		}
		return nil
	})
	if db != nil {
		return db, nil
	}
	return nil, fmt.Errorf("database %s not found", name)
}

// RegisterSyncDb Loads a sync database with given name and signature check level.
func (h Handle) RegisterSyncDb(dbname string, siglevel SigLevel) (*Db, error) {
	cName := (_Cfunc_CString)(dbname)
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cName))

	db := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char, _cgo2 _Ctype_int) *_Ctype_struct___alpm_db_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_register_syncdb)(_cgo0, _cgo1, _cgo2);}(h.ptr, cName, _Ctype_int(siglevel))
	if db == nil {
		return nil, h.LastError()
	}
	return &Db{db, h}, nil
}

// Name returns name of the db
func (db Db) Name() string {
	return (_Cfunc_GoString)(func(_cgo0 *_Ctype_struct___alpm_db_t) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_db_get_name)(_cgo0);}(db.ptr))
}

// Servers returns host server URL.
func (db Db) Servers() []string {
	ptr := unsafe.Pointer(func(_cgo0 *_Ctype_struct___alpm_db_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_db_get_servers)(_cgo0);}(db.ptr))
	return StringList{(*list)(ptr)}.Slice()
}

// SetServers sets server list to use.
func (db Db) SetServers(servers []string) {
	func(_cgo0 *_Ctype_struct___alpm_db_t, _cgo1 *_Ctype_struct___alpm_list_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_db_set_servers)(_cgo0, _cgo1);}(db.ptr, nil)
	for _, srv := range servers {
		Csrv := (_Cfunc_CString)(srv)
		defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(Csrv))
		func(_cgo0 *_Ctype_struct___alpm_db_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_db_add_server)(_cgo0, _cgo1);}(db.ptr, Csrv)
	}
}

// SetUsage sets the Usage of the database
func (db Db) SetUsage(usage Usage) {
	func(_cgo0 *_Ctype_struct___alpm_db_t, _cgo1 _Ctype_int) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_db_set_usage)(_cgo0, _cgo1);}(db.ptr, _Ctype_int(usage))
}

// PkgByName searches a package in db.
func (db Db) PkgByName(name string) (*Package, error) {
	cName := (_Cfunc_CString)(name)
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cName))
	ptr := func(_cgo0 *_Ctype_struct___alpm_db_t, _cgo1 *_Ctype_char) *_Ctype_struct___alpm_pkg_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_db_get_pkg)(_cgo0, _cgo1);}(db.ptr, cName)
	if ptr == nil {
		return nil,
			fmt.Errorf("Error when retrieving %s from database %s: %s",
				name, db.Name(), db.handle.LastError())
	}
	return &Package{ptr, db.handle}, nil
}

// PkgCachebyGroup returns a PackageList of packages belonging to a group
func (l DbList) PkgCachebyGroup(name string) (PackageList, error) {
	cName := (_Cfunc_CString)(name)
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cName))
	pkglist := (*_Ctype_struct___alpm_list_t)(unsafe.Pointer(l.list))

	pkgcache := (*list)(unsafe.Pointer(func(_cgo0 *_Ctype_struct___alpm_list_t, _cgo1 *_Ctype_char) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_find_group_pkgs)(_cgo0, _cgo1);}(pkglist, cName)))
	if pkgcache == nil {
		return PackageList{pkgcache, l.handle},
			fmt.Errorf("Error when retrieving group %s from database list: %s",
				name, l.handle.LastError())
	}

	return PackageList{pkgcache, l.handle}, nil
}

// PkgCache returns the list of packages of the database
func (db Db) PkgCache() PackageList {
	pkgcache := (*list)(unsafe.Pointer(func(_cgo0 *_Ctype_struct___alpm_db_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_db_get_pkgcache)(_cgo0);}(db.ptr)))
	return PackageList{pkgcache, db.handle}
}

func (db Db) Search(targets []string) PackageList {
	var needles *_Ctype_struct___alpm_list_t

	for _, str := range targets {
		needles = func(_cgo0 *_Ctype_struct___alpm_list_t, _cgo1 _cgo_unsafe.Pointer) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_list_add)(_cgo0, _cgo1);}(needles, unsafe.Pointer((_Cfunc_CString)(str)))
	}

	pkglist := (*list)(unsafe.Pointer(func(_cgo0 *_Ctype_struct___alpm_db_t, _cgo1 *_Ctype_struct___alpm_list_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_db_search)(_cgo0, _cgo1);}(db.ptr, needles)))
	func(_cgo0 *_Ctype_struct___alpm_list_t) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_alpm_list_free)(_cgo0);}(needles)
	return PackageList{pkglist, db.handle}
}
