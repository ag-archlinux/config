// Code generated by cmd/cgo; DO NOT EDIT.

//line /tmp/yay/src/yay-8.1173.0/.go/src/github.com/jguer/go-alpm/handle.go:1:1
// handle.go - libalpm handle type and methods.
//
// Copyright (c) 2013 The go-alpm Authors
//
// MIT Licensed. See LICENSE for details.

// Package alpm implements Go bindings to the libalpm library used by Pacman,
// the Arch Linux package manager. Libalpm allows the creation of custom front
// ends to the Arch Linux package ecosystem.
//
// Libalpm does not include support for the Arch User Repository (AUR).
package alpm; import _cgo_unsafe "unsafe"

// #include <alpm.h>
// #include <stdio.h> //C.free
// #include <fnmatch.h> //C.FNM_NOMATCH
import _ "unsafe"

import (
	"unsafe"
)

// Handle contains the pointer to the alpm handle
type Handle struct {
	ptr *_Ctype_struct___alpm_handle_t
}

// Init initializes alpm handle
func Init(root, dbpath string) (*Handle, error) {
	cRoot := (_Cfunc_CString)(root)
	cDBPath := (_Cfunc_CString)(dbpath)
	var cErr _Ctype_alpm_errno_t
	h := (_Cfunc_alpm_initialize)(cRoot, cDBPath, &cErr)

	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cRoot))
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cDBPath))

	if cErr != 0 {
		return nil, Error(cErr)
	}

	return &Handle{h}, nil
}

// Release releases the alpm handle
func (h *Handle) Release() error {
	if er := func(_cgo0 *_Ctype_struct___alpm_handle_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_release)(_cgo0);}(h.ptr); er != 0 {
		return Error(er)
	}
	h.ptr = nil
	return nil
}

// LastError gets the last pm_error
func (h Handle) LastError() error {
	if h.ptr != nil {
		cErr := func(_cgo0 *_Ctype_struct___alpm_handle_t) _Ctype_alpm_errno_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_errno)(_cgo0);}(h.ptr)
		if cErr != 0 {
			return Error(cErr)
		}
	}
	return nil
}

//
//alpm options getters and setters
//

//helper functions for wrapping list_t getters and setters
func (h Handle) optionGetList(f func(*_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t) (StringList, error) {
	alpmList := f(h.ptr)
	goList := StringList{(*list)(unsafe.Pointer(alpmList))}

	if alpmList == nil {
		return goList, h.LastError()
	}
	return goList, nil
}

func (h Handle) optionSetList(hookDirs []string, f func(*_Ctype_struct___alpm_handle_t, *_Ctype_struct___alpm_list_t) _Ctype_int) error {
	var list *_Ctype_struct___alpm_list_t

	for _, dir := range hookDirs {
		cDir := (_Cfunc_CString)(dir)
		list = func(_cgo0 *_Ctype_struct___alpm_list_t, _cgo1 _cgo_unsafe.Pointer) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_list_add)(_cgo0, _cgo1);}(list, unsafe.Pointer(cDir))
		defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cDir))
	}

	ok := f(h.ptr, list)
	if ok < 0 {
		return h.LastError()
	}
	return nil
}

func (h Handle) optionAddList(hookDir string, f func(*_Ctype_struct___alpm_handle_t, *_Ctype_char) _Ctype_int) error {
	cHookDir := (_Cfunc_CString)(hookDir)
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cHookDir))
	ok := f(h.ptr, cHookDir)
	if ok < 0 {
		return h.LastError()
	}
	return nil
}

func (h Handle) optionRemoveList(dir string, f func(*_Ctype_struct___alpm_handle_t, *_Ctype_char) _Ctype_int) (bool, error) {
	cDir := (_Cfunc_CString)(dir)
	ok := f(h.ptr, cDir)
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cDir))
	if ok < 0 {
		return ok == 1, h.LastError()
	}
	return ok == 1, nil
}

func (h Handle) optionMatchList(dir string, f func(*_Ctype_struct___alpm_handle_t, *_Ctype_char) _Ctype_int) (bool, error) {
	cDir := (_Cfunc_CString)(dir)
	ok := f(h.ptr, cDir)
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cDir))
	if ok == 0 {
		return true, nil
	} else if ok == (_Ciconst_FNM_NOMATCH) {
		return false, h.LastError()
	}
	return false, nil
}

//helper functions for *char based getters and setters
func (h Handle) optionGetStr(f func(*_Ctype_struct___alpm_handle_t) *_Ctype_char) (string, error) {
	cStr := f(h.ptr)
	str := (_Cfunc_GoString)(cStr)
	if cStr == nil {
		return str, h.LastError()
	}

	return str, nil
}

func (h Handle) optionSetStr(str string, f func(*_Ctype_struct___alpm_handle_t, *_Ctype_char) _Ctype_int) error {
	cStr := (_Cfunc_CString)(str)
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cStr))
	ok := f(h.ptr, cStr)

	if ok < 0 {
		h.LastError()
	}
	return nil
}

//
//end of helpers
//

func (h Handle) Root() (string, error) {
	return h.optionGetStr(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_char {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_root)(_cgo0);}(handle)
	})
}

func (h Handle) DBPath() (string, error) {
	return h.optionGetStr(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_char {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_dbpath)(_cgo0);}(handle)
	})
}

func (h Handle) Lockfile() (string, error) {
	return h.optionGetStr(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_char {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_lockfile)(_cgo0);}(handle)
	})
}

func (h Handle) CacheDirs() (StringList, error) {
	return h.optionGetList(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_cachedirs)(_cgo0);}(handle)
	})
}

func (h Handle) AddCacheDir(hookDir string) error {
	return h.optionAddList(hookDir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_add_cachedir)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) SetCacheDirs(hookDirs ...string) error {
	return h.optionSetList(hookDirs, func(handle *_Ctype_struct___alpm_handle_t, l *_Ctype_struct___alpm_list_t) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct___alpm_list_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_set_cachedirs)(_cgo0, _cgo1);}(handle, l)
	})
}

func (h Handle) RemoveCacheDir(dir string) (bool, error) {
	return h.optionRemoveList(dir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_remove_cachedir)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) HookDirs() (StringList, error) {
	return h.optionGetList(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_hookdirs)(_cgo0);}(handle)
	})
}

func (h Handle) AddHookDir(hookDir string) error {
	return h.optionAddList(hookDir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_add_hookdir)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) SetHookDirs(hookDirs ...string) error {
	return h.optionSetList(hookDirs, func(handle *_Ctype_struct___alpm_handle_t, l *_Ctype_struct___alpm_list_t) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct___alpm_list_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_set_hookdirs)(_cgo0, _cgo1);}(handle, l)
	})
}

func (h Handle) RemoveHookDir(dir string) (bool, error) {
	return h.optionRemoveList(dir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_remove_hookdir)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) LogFile() (string, error) {
	return h.optionGetStr(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_char {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_logfile)(_cgo0);}(handle)
	})
}

func (h Handle) SetLogFile(str string) error {
	return h.optionSetStr(str, func(handle *_Ctype_struct___alpm_handle_t, c_str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_logfile)(_cgo0, _cgo1);}(handle, c_str)
	})
}

func (h Handle) GPGDir() (string, error) {
	return h.optionGetStr(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_char {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_gpgdir)(_cgo0);}(handle)
	})
}

func (h Handle) SetGPGDir(str string) error {
	return h.optionSetStr(str, func(handle *_Ctype_struct___alpm_handle_t, c_str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_gpgdir)(_cgo0, _cgo1);}(handle, c_str)
	})
}

func (h Handle) UseSyslog() (bool, error) {
	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_usesyslog)(_cgo0);}(h.ptr)
	b := false

	if ok > 0 {
		b = true
	}
	if ok < 0 {
		return b, h.LastError()
	}
	return b, nil
}

func (h Handle) SetUseSyslog(value bool) error {
	var intValue _Ctype_int
	if value {
		intValue = 1
	}

	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 _Ctype_int) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_usesyslog)(_cgo0, _cgo1);}(h.ptr, intValue)
	if ok < 0 {
		return h.LastError()
	}
	return nil
}

func (h Handle) NoUpgrades() (StringList, error) {
	return h.optionGetList(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_noupgrades)(_cgo0);}(handle)
	})
}

func (h Handle) AddNoUpgrade(hookDir string) error {
	return h.optionAddList(hookDir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_add_noupgrade)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) SetNoUpgrades(hookDirs ...string) error {
	return h.optionSetList(hookDirs, func(handle *_Ctype_struct___alpm_handle_t, l *_Ctype_struct___alpm_list_t) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct___alpm_list_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_set_noupgrades)(_cgo0, _cgo1);}(handle, l)
	})
}

func (h Handle) RemoveNoUpgrade(dir string) (bool, error) {
	return h.optionRemoveList(dir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_remove_noupgrade)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) MatchNoUpgrade(dir string) (bool, error) {
	return h.optionMatchList(dir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_match_noupgrade)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) NoExtracts() (StringList, error) {
	return h.optionGetList(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_noextracts)(_cgo0);}(handle)
	})
}

func (h Handle) AddNoExtract(hookDir string) error {
	return h.optionAddList(hookDir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_add_noextract)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) SetNoExtracts(hookDirs ...string) error {
	return h.optionSetList(hookDirs, func(handle *_Ctype_struct___alpm_handle_t, l *_Ctype_struct___alpm_list_t) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct___alpm_list_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_set_noextracts)(_cgo0, _cgo1);}(handle, l)
	})
}

func (h Handle) RemoveNoExtract(dir string) (bool, error) {
	return h.optionRemoveList(dir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_remove_noextract)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) MatchNoExtract(dir string) (bool, error) {
	return h.optionMatchList(dir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_match_noextract)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) IgnorePkgs() (StringList, error) {
	return h.optionGetList(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_ignorepkgs)(_cgo0);}(handle)
	})
}

func (h Handle) AddIgnorePkg(hookDir string) error {
	return h.optionAddList(hookDir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_add_ignorepkg)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) SetIgnorePkgs(hookDirs ...string) error {
	return h.optionSetList(hookDirs, func(handle *_Ctype_struct___alpm_handle_t, l *_Ctype_struct___alpm_list_t) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct___alpm_list_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_set_ignorepkgs)(_cgo0, _cgo1);}(handle, l)
	})
}

func (h Handle) RemoveIgnorePkg(dir string) (bool, error) {
	return h.optionRemoveList(dir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_remove_ignorepkg)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) IgnoreGroups() (StringList, error) {
	return h.optionGetList(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_ignoregroups)(_cgo0);}(handle)
	})
}

func (h Handle) AddIgnoreGroup(hookDir string) error {
	return h.optionAddList(hookDir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_add_ignoregroup)(_cgo0, _cgo1);}(handle, str)
	})
}

func (h Handle) SetIgnoreGroups(hookDirs ...string) error {
	return h.optionSetList(hookDirs, func(handle *_Ctype_struct___alpm_handle_t, l *_Ctype_struct___alpm_list_t) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct___alpm_list_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_set_ignoregroups)(_cgo0, _cgo1);}(handle, l)
	})
}

func (h Handle) RemoveIgnoreGroup(dir string) (bool, error) {
	return h.optionRemoveList(dir, func(handle *_Ctype_struct___alpm_handle_t, str *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_remove_ignoregroup)(_cgo0, _cgo1);}(handle, str)
	})
}

/*func (h Handle) optionGetList(f func(*C.alpm_handle_t) *C.alpm_list_t) (StringList, error){
	alpmList := f(h.ptr)
	goList := StringList{(*list)(unsafe.Pointer(alpmList))}

	if alpmList == nil {
		return goList, h.LastError()
	}
	return goList, nil
}*/

//use alpm_depend_t
func (h Handle) AssumeInstalled() (DependList, error) {
	alpmList := func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_assumeinstalled)(_cgo0);}(h.ptr)
	depList := DependList{(*list)(unsafe.Pointer(alpmList))}

	if alpmList == nil {
		return depList, h.LastError()
	}
	return depList, nil
}

func (h Handle) AddAssumeInstalled(dep Depend) error {
	cDep := convertCDepend(dep)
	defer freeCDepend(cDep)

	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct__alpm_depend_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_add_assumeinstalled)(_cgo0, _cgo1);}(h.ptr, cDep)
	if ok < 0 {
		return h.LastError()
	}
	return nil
}

func (h Handle) SetAssumeInstalled(deps ...Depend) error {
	//calling this function the first time causes alpm to set the
	//assumeinstalled list to a list containing go allocated alpm_depend_t's
	//this is bad because alpm might at some point tree to free them
	//i believe this is whats causing this function to misbhave
	//although i am not 100% sure
	//maybe using C.malloc to make the struct could fix the problem
	//pacamn does not use alpm_option_set_assumeinstalled in its source
	//code so anybody using this should beable to do file without it
	//although for the sake of completeness it would be nice to have this
	//working
	panic("This function (SetAssumeInstalled) does not work properly, please do not use. See source code for more details")
	var list *_Ctype_struct___alpm_list_t

	for _, dep := range deps {
		cDep := convertCDepend(dep)
		defer freeCDepend(cDep)
		list = func(_cgo0 *_Ctype_struct___alpm_list_t, _cgo1 _cgo_unsafe.Pointer) *_Ctype_struct___alpm_list_t {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_list_add)(_cgo0, _cgo1);}(list, unsafe.Pointer(cDep))
	}

	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct___alpm_list_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_set_assumeinstalled)(_cgo0, _cgo1);}(h.ptr, list)
	if ok < 0 {
		return h.LastError()
	}
	return nil

}

func (h Handle) RemoveAssumeInstalled(dep Depend) (bool, error) {
	//internally alpm uses alpm_list_remove to remove a alpm_depend_t from
	//the list
	//i believe this function considers items equal if they are the same
	//item in memeory, not just the same data
	//every time we convert a go Depend to a alpm_depend_c we create a new
	//instance of a alpm_depend_c
	//this means that if you add a Depend using AddAssumeInstalled then try
	//to remove it using the same Depend c will consider them different
	//items and not remove them
	//pacamn does not use alpm_option_set_assumeinstalled in its source
	//code so anybody using this should beable to do file without it
	//although for the sake of completeness it would be nice to have this
	//working
	panic("This function (RemoveAssumeInstalled) does not work properly, please do not use. See source code for more details")
	cDep := convertCDepend(dep)
	defer freeCDepend(cDep)

	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_struct__alpm_depend_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	_cgoCheckPointer(_cgo1);	return (_Cfunc_alpm_option_remove_assumeinstalled)(_cgo0, _cgo1);}(h.ptr, cDep)
	if ok < 0 {
		return ok == 1, h.LastError()
	}
	return ok == 1, nil
}

func (h Handle) Arch() (string, error) {
	return h.optionGetStr(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_char {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_arch)(_cgo0);}(handle)
	})
}

func (h Handle) SetArch(str string) error {
	return h.optionSetStr(str, func(handle *_Ctype_struct___alpm_handle_t, cStr *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_arch)(_cgo0, _cgo1);}(handle, cStr)
	})
}

func (h Handle) DeltaRatio() (float64, error) {
	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t) _Ctype_double {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_deltaratio)(_cgo0);}(h.ptr)
	if ok < 0 {
		return float64(ok), h.LastError()
	}
	return float64(ok), nil
}

func (h Handle) SetDeltaRatio(ratio float64) error {
	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 _Ctype_double) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_deltaratio)(_cgo0, _cgo1);}(h.ptr, _Ctype_double(ratio))
	if ok < 0 {
		return h.LastError()
	}
	return nil
}

func (h Handle) CheckSpace() (bool, error) {
	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_checkspace)(_cgo0);}(h.ptr)
	b := false

	if ok > 0 {
		b = true
	}
	if ok < 0 {
		return b, h.LastError()
	}
	return b, nil
}

func (h Handle) SetCheckSpace(value bool) error {
	var cValue _Ctype_int
	if value {
		cValue = 1
	}

	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 _Ctype_int) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_checkspace)(_cgo0, _cgo1);}(h.ptr, cValue)
	if ok < 0 {
		return h.LastError()
	}
	return nil
}

func (h Handle) DBExt() (string, error) {
	return h.optionGetStr(func(handle *_Ctype_struct___alpm_handle_t) *_Ctype_char {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_dbext)(_cgo0);}(handle)
	})
}

func (h Handle) SetDBExt(str string) error {
	return h.optionSetStr(str, func(handle *_Ctype_struct___alpm_handle_t, cStr *_Ctype_char) _Ctype_int {
		return func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 *_Ctype_char) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_dbext)(_cgo0, _cgo1);}(handle, cStr)
	})
}

func (h Handle) GetDefaultSigLevel() (SigLevel, error) {
	sigLevel := func(_cgo0 *_Ctype_struct___alpm_handle_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_default_siglevel)(_cgo0);}(h.ptr)

	if sigLevel < 0 {
		return SigLevel(sigLevel), h.LastError()
	}
	return SigLevel(sigLevel), nil
}

func (h Handle) SetDefaultSigLevel(siglevel SigLevel) error {
	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 _Ctype_int) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_default_siglevel)(_cgo0, _cgo1);}(h.ptr, _Ctype_int(siglevel))

	if ok < 0 {
		return h.LastError()
	}
	return nil
}

func (h Handle) GetLocalFileSigLevel() (SigLevel, error) {
	sigLevel := func(_cgo0 *_Ctype_struct___alpm_handle_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_local_file_siglevel)(_cgo0);}(h.ptr)

	if sigLevel < 0 {
		return SigLevel(sigLevel), h.LastError()
	}
	return SigLevel(sigLevel), nil
}

func (h Handle) SetLocalFileSigLevel(siglevel SigLevel) error {
	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 _Ctype_int) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_local_file_siglevel)(_cgo0, _cgo1);}(h.ptr, _Ctype_int(siglevel))

	if ok < 0 {
		return h.LastError()
	}
	return nil
}

func (h Handle) GetRemoteFileSigLevel() (SigLevel, error) {
	sigLevel := func(_cgo0 *_Ctype_struct___alpm_handle_t) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_get_remote_file_siglevel)(_cgo0);}(h.ptr)

	if sigLevel < 0 {
		return SigLevel(sigLevel), h.LastError()
	}
	return SigLevel(sigLevel), nil
}

func (h Handle) SetRemoteFileSigLevel(siglevel SigLevel) error {
	ok := func(_cgo0 *_Ctype_struct___alpm_handle_t, _cgo1 _Ctype_int) _Ctype_int {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_alpm_option_set_remote_file_siglevel)(_cgo0, _cgo1);}(h.ptr, _Ctype_int(siglevel))

	if ok < 0 {
		return h.LastError()
	}
	return nil
}
