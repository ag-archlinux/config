// Code generated by cmd/cgo; DO NOT EDIT.

//line /tmp/yay/src/yay-8.1173.0/.go/src/github.com/jguer/go-alpm/types.go:1:1
// types.go - libalpm types.
//
// Copyright (c) 2013 The go-alpm Authors
//
// MIT Licensed. See LICENSE for details.

package alpm; import _cgo_unsafe "unsafe"

// #cgo CFLAGS: -D_FILE_OFFSET_BITS=64
// #include <alpm.h>
import _ "unsafe"

import (
	"fmt"
	"reflect"
	"unsafe"
)

// Depend provides a description of a dependency.
type Depend struct {
	Name        string
	Version     string
	Description string
	NameHash    uint
	Mod         DepMod
}

func convertDepend(dep *_Ctype_struct__alpm_depend_t) Depend {
	return Depend{
		Name:        (_Cfunc_GoString)(dep.name),
		Version:     (_Cfunc_GoString)(dep.version),
		Mod:         DepMod(dep.mod),
		Description: (_Cfunc_GoString)(dep.desc),
		NameHash:    uint(dep.name_hash),
	}
}

func convertCDepend(dep Depend) *_Ctype_struct__alpm_depend_t {
	cName := (_Cfunc_CString)(dep.Name)
	cVersion := (_Cfunc_CString)(dep.Version)
	cDesc := (_Cfunc_CString)(dep.Description)

	cDep := _Ctype_struct__alpm_depend_t{
		name:      cName,
		version:   cVersion,
		desc:      cDesc,
		name_hash: _Ctype_ulong(dep.NameHash),
		mod:       _Ctype_alpm_depmod_t(dep.Mod),
	}

	return &cDep
}

func freeCDepend(dep *_Ctype_struct__alpm_depend_t) {
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(dep.name))
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(dep.version))
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(dep.desc))
}

func (dep Depend) String() string {
	return dep.Name + dep.Mod.String() + dep.Version
}

// File provides a description of package files.
type File struct {
	Name string
	Size int64
	Mode uint32
}

func convertFilelist(files *_Ctype_struct__alpm_filelist_t) []File {
	size := int(files.count)
	items := make([]File, size)

	rawItems := reflect.SliceHeader{
		Len:  size,
		Cap:  size,
		Data: uintptr(unsafe.Pointer(files.files))}

	cFiles := *(*[]_Ctype_struct__alpm_file_t)(unsafe.Pointer(&rawItems))

	for i := 0; i < size; i++ {
		items[i] = File{
			Name: (_Cfunc_GoString)(cFiles[i].name),
			Size: int64(cFiles[i].size),
			Mode: uint32(cFiles[i].mode)}
	}
	return items
}

// Internal alpm list structure.
type list struct {
	Data unsafe.Pointer
	Prev *list
	Next *list
}

// Iterates a function on a list and stop on error.
func (l *list) forEach(f func(unsafe.Pointer) error) error {
	for ; l != nil; l = l.Next {
		err := f(l.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

type StringList struct {
	*list
}

func (l StringList) ForEach(f func(string) error) error {
	return l.forEach(func(p unsafe.Pointer) error {
		return f((_Cfunc_GoString)((*_Ctype_char)(p)))
	})
}

func (l StringList) Slice() []string {
	slice := []string{}
	l.ForEach(func(s string) error {
		slice = append(slice, s)
		return nil
	})
	return slice
}

type BackupFile struct {
	Name string
	Hash string
}

type BackupList struct {
	*list
}

func (l BackupList) ForEach(f func(BackupFile) error) error {
	return l.forEach(func(p unsafe.Pointer) error {
		bf := (*_Ctype_struct__alpm_backup_t)(p)
		return f(BackupFile{
			Name: (_Cfunc_GoString)(bf.name),
			Hash: (_Cfunc_GoString)(bf.hash),
		})
	})
}

func (l BackupList) Slice() (slice []BackupFile) {
	l.ForEach(func(f BackupFile) error {
		slice = append(slice, f)
		return nil
	})
	return
}

type QuestionAny struct {
	ptr *_Ctype_struct__alpm_question_any_t
}

func (question QuestionAny) SetAnswer(answer bool) {
	if answer {
		question.ptr.answer = 1
	} else {
		question.ptr.answer = 0
	}
}

type QuestionInstallIgnorepkg struct {
	ptr *_Ctype_struct__alpm_question_install_ignorepkg_t
}

func (question QuestionAny) Type() QuestionType {
	return QuestionType(question.ptr._type)
}

func (question QuestionAny) Answer() bool {
	return question.ptr.answer == 1
}

func (question QuestionAny) QuestionInstallIgnorepkg() (QuestionInstallIgnorepkg, error) {
	if question.Type() == QuestionTypeInstallIgnorepkg {
		return *(*QuestionInstallIgnorepkg)(unsafe.Pointer(&question)), nil
	}

	return QuestionInstallIgnorepkg{}, fmt.Errorf("Can not convert to QuestionInstallIgnorepkg")
}

func (question QuestionAny) QuestionSelectProvider() (QuestionSelectProvider, error) {
	if question.Type() == QuestionTypeSelectProvider {
		return *(*QuestionSelectProvider)(unsafe.Pointer(&question)), nil
	}

	return QuestionSelectProvider{}, fmt.Errorf("Can not convert to QuestionInstallIgnorepkg")
}

func (question QuestionAny) QuestionReplace() (QuestionReplace, error) {
	if question.Type() == QuestionTypeReplacePkg {
		return *(*QuestionReplace)(unsafe.Pointer(&question)), nil
	}

	return QuestionReplace{}, fmt.Errorf("Can not convert to QuestionReplace")
}

func (question QuestionInstallIgnorepkg) SetInstall(install bool) {
	if install {
		question.ptr.install = 1
	} else {
		question.ptr.install = 0
	}
}

func (question QuestionInstallIgnorepkg) Type() QuestionType {
	return QuestionType(question.ptr._type)
}

func (question QuestionInstallIgnorepkg) Install() bool {
	return question.ptr.install == 1
}

func (question QuestionInstallIgnorepkg) Pkg(h *Handle) Package {
	return Package{
		question.ptr.pkg,
		*h,
	}
}

type QuestionReplace struct {
	ptr *_Ctype_struct__alpm_question_replace_t
}

func (question QuestionReplace) Type() QuestionType {
	return QuestionType(question.ptr._type)
}

func (question QuestionReplace) SetReplace(replace bool) {
	if replace {
		question.ptr.replace = 1
	} else {
		question.ptr.replace = 0
	}
}

func (question QuestionReplace) Replace() bool {
	return question.ptr.replace == 1
}

func (question QuestionReplace) NewPkg(h *Handle) Package {
	return Package{
		question.ptr.newpkg,
		*h,
	}
}

func (question QuestionReplace) OldPkg(h *Handle) Package {
	return Package{
		question.ptr.oldpkg,
		*h,
	}
}

func (question QuestionReplace) newDb(h *Handle) Db {
	return Db{
		question.ptr.newdb,
		*h,
	}
}

type QuestionSelectProvider struct {
	ptr *_Ctype_struct__alpm_question_select_provider_t
}

func (question QuestionSelectProvider) Type() QuestionType {
	return QuestionType(question.ptr._type)
}

func (question QuestionSelectProvider) SetUseIndex(index int) {
	question.ptr.use_index = _Ctype_int(index)
}

func (question QuestionSelectProvider) UseIndex() int {
	return int(question.ptr.use_index)
}

func (question QuestionSelectProvider) Providers(h *Handle) PackageList {
	return PackageList{
		(*list)(unsafe.Pointer(question.ptr.providers)),
		*h,
	}
}

func (question QuestionSelectProvider) Dep() Depend {
	return convertDepend(question.ptr.depend)
}
